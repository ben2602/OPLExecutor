//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.4-2 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2017.03.13 at 10:49:01 AM CET 
//


package org.imf.oplexecutor.fims.desc;

import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlSchemaType;
import javax.xml.bind.annotation.XmlSeeAlso;
import javax.xml.bind.annotation.XmlType;
import javax.xml.bind.annotation.adapters.CollapsedStringAdapter;
import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;


/**
 * Introduced In Version:
 * 				1_0_7
 * 
 * <p>Java class for bmContentDescriptionType complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="bmContentDescriptionType">
 *   &lt;complexContent>
 *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *       &lt;sequence>
 *         &lt;element name="title" type="{http://description.fims.tv}titleType" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="alternativeTitle" type="{http://description.fims.tv}alternativeTitleType" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="creator" type="{http://description.fims.tv}entityType" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="subject" type="{http://description.fims.tv}subjectType" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="description" type="{http://description.fims.tv}descriptionType" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="publisher" type="{http://description.fims.tv}entityType" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="contributor" type="{http://description.fims.tv}entityType" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="date" type="{http://description.fims.tv}dateType" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="type" type="{http://description.fims.tv}typeType" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="identifier" type="{http://description.fims.tv}identifierType" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="language" type="{http://description.fims.tv}languageType" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="relation" type="{http://description.fims.tv}relationType" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="isVersionOf" type="{http://description.fims.tv}relationType" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="hasVersion" type="{http://description.fims.tv}relationType" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="isReplacedBy" type="{http://description.fims.tv}relationType" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="replaces" type="{http://description.fims.tv}relationType" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="isRequiredBy" type="{http://description.fims.tv}relationType" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="requires" type="{http://description.fims.tv}relationType" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="isPartOf" type="{http://description.fims.tv}relationType" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="hasPart" type="{http://description.fims.tv}relationType" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="isReferencedBy" type="{http://description.fims.tv}relationType" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="references" type="{http://description.fims.tv}relationType" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="isFormatOf" type="{http://description.fims.tv}relationType" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="hasFormat" type="{http://description.fims.tv}relationType" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="isRelatedTo" type="{http://description.fims.tv}relationType" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="isEpisodeOf" type="{http://description.fims.tv}relationType" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="hasEpisode" type="{http://description.fims.tv}relationType" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="isSeriesOf" type="{http://description.fims.tv}relationType" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="hasSeries" type="{http://description.fims.tv}relationType" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="isSeasonOf" type="{http://description.fims.tv}relationType" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="hasSeason" type="{http://description.fims.tv}relationType" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="isNextInSequence" type="{http://description.fims.tv}relationType" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="followsInSequence" type="{http://description.fims.tv}relationType" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="sameAs" type="{http://description.fims.tv}relationType" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="isMemberOf" type="{http://description.fims.tv}relationType" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="hasMember" type="{http://description.fims.tv}relationType" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="coverage" type="{http://description.fims.tv}coverageType" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="rights" type="{http://description.fims.tv}rightsType" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="version" minOccurs="0">
 *           &lt;complexType>
 *             &lt;simpleContent>
 *               &lt;extension base="&lt;http://description.fims.tv>textElementType">
 *                 &lt;attGroup ref="{http://description.fims.tv}typeGroup"/>
 *               &lt;/extension>
 *             &lt;/simpleContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="rating" type="{http://description.fims.tv}ratingType" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="audienceRating" type="{http://description.fims.tv}ratingType" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="part" type="{http://description.fims.tv}partType" maxOccurs="unbounded" minOccurs="0"/>
 *       &lt;/sequence>
 *       &lt;attribute ref="{http://www.w3.org/XML/1998/namespace}lang"/>
 *     &lt;/restriction>
 *   &lt;/complexContent>
 * &lt;/complexType>
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "bmContentDescriptionType", propOrder = {
    "title",
    "alternativeTitle",
    "creator",
    "subject",
    "description",
    "publisher",
    "contributor",
    "date",
    "type",
    "identifier",
    "language",
    "relation",
    "isVersionOf",
    "hasVersion",
    "isReplacedBy",
    "replaces",
    "isRequiredBy",
    "requires",
    "isPartOf",
    "hasPart",
    "isReferencedBy",
    "references",
    "isFormatOf",
    "hasFormat",
    "isRelatedTo",
    "isEpisodeOf",
    "hasEpisode",
    "isSeriesOf",
    "hasSeries",
    "isSeasonOf",
    "hasSeason",
    "isNextInSequence",
    "followsInSequence",
    "sameAs",
    "isMemberOf",
    "hasMember",
    "coverage",
    "rights",
    "version",
    "rating",
    "audienceRating",
    "part"
})
@XmlSeeAlso({
    PartType.class
})
public class BmContentDescriptionType {

    protected List<TitleType> title;
    protected List<AlternativeTitleType> alternativeTitle;
    protected List<EntityType> creator;
    protected List<SubjectType> subject;
    protected List<DescriptionType> description;
    protected List<EntityType> publisher;
    protected List<EntityType> contributor;
    protected List<DateType> date;
    protected List<TypeType> type;
    protected List<IdentifierType> identifier;
    protected List<LanguageType> language;
    protected List<RelationType> relation;
    protected List<RelationType> isVersionOf;
    protected List<RelationType> hasVersion;
    protected List<RelationType> isReplacedBy;
    protected List<RelationType> replaces;
    protected List<RelationType> isRequiredBy;
    protected List<RelationType> requires;
    protected List<RelationType> isPartOf;
    protected List<RelationType> hasPart;
    protected List<RelationType> isReferencedBy;
    protected List<RelationType> references;
    protected List<RelationType> isFormatOf;
    protected List<RelationType> hasFormat;
    protected List<RelationType> isRelatedTo;
    protected List<RelationType> isEpisodeOf;
    protected List<RelationType> hasEpisode;
    protected List<RelationType> isSeriesOf;
    protected List<RelationType> hasSeries;
    protected List<RelationType> isSeasonOf;
    protected List<RelationType> hasSeason;
    protected List<RelationType> isNextInSequence;
    protected List<RelationType> followsInSequence;
    protected List<RelationType> sameAs;
    protected List<RelationType> isMemberOf;
    protected List<RelationType> hasMember;
    protected List<CoverageType> coverage;
    protected List<RightsType> rights;
    protected BmContentDescriptionType.Version version;
    protected List<RatingType> rating;
    protected List<RatingType> audienceRating;
    protected List<PartType> part;
    @XmlAttribute(name = "lang", namespace = "http://www.w3.org/XML/1998/namespace")
    @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
    @XmlSchemaType(name = "language")
    protected String lang;

    /**
     * Gets the value of the title property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the title property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getTitle().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link TitleType }
     * 
     * 
     */
    public List<TitleType> getTitle() {
        if (title == null) {
            title = new ArrayList<TitleType>();
        }
        return this.title;
    }

    /**
     * Gets the value of the alternativeTitle property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the alternativeTitle property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getAlternativeTitle().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link AlternativeTitleType }
     * 
     * 
     */
    public List<AlternativeTitleType> getAlternativeTitle() {
        if (alternativeTitle == null) {
            alternativeTitle = new ArrayList<AlternativeTitleType>();
        }
        return this.alternativeTitle;
    }

    /**
     * Gets the value of the creator property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the creator property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getCreator().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link EntityType }
     * 
     * 
     */
    public List<EntityType> getCreator() {
        if (creator == null) {
            creator = new ArrayList<EntityType>();
        }
        return this.creator;
    }

    /**
     * Gets the value of the subject property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the subject property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getSubject().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link SubjectType }
     * 
     * 
     */
    public List<SubjectType> getSubject() {
        if (subject == null) {
            subject = new ArrayList<SubjectType>();
        }
        return this.subject;
    }

    /**
     * Gets the value of the description property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the description property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getDescription().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link DescriptionType }
     * 
     * 
     */
    public List<DescriptionType> getDescription() {
        if (description == null) {
            description = new ArrayList<DescriptionType>();
        }
        return this.description;
    }

    /**
     * Gets the value of the publisher property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the publisher property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getPublisher().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link EntityType }
     * 
     * 
     */
    public List<EntityType> getPublisher() {
        if (publisher == null) {
            publisher = new ArrayList<EntityType>();
        }
        return this.publisher;
    }

    /**
     * Gets the value of the contributor property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the contributor property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getContributor().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link EntityType }
     * 
     * 
     */
    public List<EntityType> getContributor() {
        if (contributor == null) {
            contributor = new ArrayList<EntityType>();
        }
        return this.contributor;
    }

    /**
     * Gets the value of the date property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the date property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getDate().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link DateType }
     * 
     * 
     */
    public List<DateType> getDate() {
        if (date == null) {
            date = new ArrayList<DateType>();
        }
        return this.date;
    }

    /**
     * Gets the value of the type property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the type property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getType().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link TypeType }
     * 
     * 
     */
    public List<TypeType> getType() {
        if (type == null) {
            type = new ArrayList<TypeType>();
        }
        return this.type;
    }

    /**
     * Gets the value of the identifier property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the identifier property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getIdentifier().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link IdentifierType }
     * 
     * 
     */
    public List<IdentifierType> getIdentifier() {
        if (identifier == null) {
            identifier = new ArrayList<IdentifierType>();
        }
        return this.identifier;
    }

    /**
     * Gets the value of the language property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the language property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getLanguage().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link LanguageType }
     * 
     * 
     */
    public List<LanguageType> getLanguage() {
        if (language == null) {
            language = new ArrayList<LanguageType>();
        }
        return this.language;
    }

    /**
     * Gets the value of the relation property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the relation property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getRelation().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link RelationType }
     * 
     * 
     */
    public List<RelationType> getRelation() {
        if (relation == null) {
            relation = new ArrayList<RelationType>();
        }
        return this.relation;
    }

    /**
     * Gets the value of the isVersionOf property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the isVersionOf property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getIsVersionOf().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link RelationType }
     * 
     * 
     */
    public List<RelationType> getIsVersionOf() {
        if (isVersionOf == null) {
            isVersionOf = new ArrayList<RelationType>();
        }
        return this.isVersionOf;
    }

    /**
     * Gets the value of the hasVersion property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the hasVersion property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getHasVersion().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link RelationType }
     * 
     * 
     */
    public List<RelationType> getHasVersion() {
        if (hasVersion == null) {
            hasVersion = new ArrayList<RelationType>();
        }
        return this.hasVersion;
    }

    /**
     * Gets the value of the isReplacedBy property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the isReplacedBy property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getIsReplacedBy().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link RelationType }
     * 
     * 
     */
    public List<RelationType> getIsReplacedBy() {
        if (isReplacedBy == null) {
            isReplacedBy = new ArrayList<RelationType>();
        }
        return this.isReplacedBy;
    }

    /**
     * Gets the value of the replaces property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the replaces property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getReplaces().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link RelationType }
     * 
     * 
     */
    public List<RelationType> getReplaces() {
        if (replaces == null) {
            replaces = new ArrayList<RelationType>();
        }
        return this.replaces;
    }

    /**
     * Gets the value of the isRequiredBy property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the isRequiredBy property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getIsRequiredBy().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link RelationType }
     * 
     * 
     */
    public List<RelationType> getIsRequiredBy() {
        if (isRequiredBy == null) {
            isRequiredBy = new ArrayList<RelationType>();
        }
        return this.isRequiredBy;
    }

    /**
     * Gets the value of the requires property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the requires property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getRequires().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link RelationType }
     * 
     * 
     */
    public List<RelationType> getRequires() {
        if (requires == null) {
            requires = new ArrayList<RelationType>();
        }
        return this.requires;
    }

    /**
     * Gets the value of the isPartOf property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the isPartOf property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getIsPartOf().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link RelationType }
     * 
     * 
     */
    public List<RelationType> getIsPartOf() {
        if (isPartOf == null) {
            isPartOf = new ArrayList<RelationType>();
        }
        return this.isPartOf;
    }

    /**
     * Gets the value of the hasPart property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the hasPart property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getHasPart().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link RelationType }
     * 
     * 
     */
    public List<RelationType> getHasPart() {
        if (hasPart == null) {
            hasPart = new ArrayList<RelationType>();
        }
        return this.hasPart;
    }

    /**
     * Gets the value of the isReferencedBy property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the isReferencedBy property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getIsReferencedBy().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link RelationType }
     * 
     * 
     */
    public List<RelationType> getIsReferencedBy() {
        if (isReferencedBy == null) {
            isReferencedBy = new ArrayList<RelationType>();
        }
        return this.isReferencedBy;
    }

    /**
     * Gets the value of the references property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the references property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getReferences().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link RelationType }
     * 
     * 
     */
    public List<RelationType> getReferences() {
        if (references == null) {
            references = new ArrayList<RelationType>();
        }
        return this.references;
    }

    /**
     * Gets the value of the isFormatOf property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the isFormatOf property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getIsFormatOf().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link RelationType }
     * 
     * 
     */
    public List<RelationType> getIsFormatOf() {
        if (isFormatOf == null) {
            isFormatOf = new ArrayList<RelationType>();
        }
        return this.isFormatOf;
    }

    /**
     * Gets the value of the hasFormat property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the hasFormat property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getHasFormat().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link RelationType }
     * 
     * 
     */
    public List<RelationType> getHasFormat() {
        if (hasFormat == null) {
            hasFormat = new ArrayList<RelationType>();
        }
        return this.hasFormat;
    }

    /**
     * Gets the value of the isRelatedTo property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the isRelatedTo property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getIsRelatedTo().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link RelationType }
     * 
     * 
     */
    public List<RelationType> getIsRelatedTo() {
        if (isRelatedTo == null) {
            isRelatedTo = new ArrayList<RelationType>();
        }
        return this.isRelatedTo;
    }

    /**
     * Gets the value of the isEpisodeOf property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the isEpisodeOf property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getIsEpisodeOf().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link RelationType }
     * 
     * 
     */
    public List<RelationType> getIsEpisodeOf() {
        if (isEpisodeOf == null) {
            isEpisodeOf = new ArrayList<RelationType>();
        }
        return this.isEpisodeOf;
    }

    /**
     * Gets the value of the hasEpisode property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the hasEpisode property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getHasEpisode().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link RelationType }
     * 
     * 
     */
    public List<RelationType> getHasEpisode() {
        if (hasEpisode == null) {
            hasEpisode = new ArrayList<RelationType>();
        }
        return this.hasEpisode;
    }

    /**
     * Gets the value of the isSeriesOf property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the isSeriesOf property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getIsSeriesOf().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link RelationType }
     * 
     * 
     */
    public List<RelationType> getIsSeriesOf() {
        if (isSeriesOf == null) {
            isSeriesOf = new ArrayList<RelationType>();
        }
        return this.isSeriesOf;
    }

    /**
     * Gets the value of the hasSeries property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the hasSeries property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getHasSeries().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link RelationType }
     * 
     * 
     */
    public List<RelationType> getHasSeries() {
        if (hasSeries == null) {
            hasSeries = new ArrayList<RelationType>();
        }
        return this.hasSeries;
    }

    /**
     * Gets the value of the isSeasonOf property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the isSeasonOf property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getIsSeasonOf().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link RelationType }
     * 
     * 
     */
    public List<RelationType> getIsSeasonOf() {
        if (isSeasonOf == null) {
            isSeasonOf = new ArrayList<RelationType>();
        }
        return this.isSeasonOf;
    }

    /**
     * Gets the value of the hasSeason property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the hasSeason property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getHasSeason().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link RelationType }
     * 
     * 
     */
    public List<RelationType> getHasSeason() {
        if (hasSeason == null) {
            hasSeason = new ArrayList<RelationType>();
        }
        return this.hasSeason;
    }

    /**
     * Gets the value of the isNextInSequence property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the isNextInSequence property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getIsNextInSequence().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link RelationType }
     * 
     * 
     */
    public List<RelationType> getIsNextInSequence() {
        if (isNextInSequence == null) {
            isNextInSequence = new ArrayList<RelationType>();
        }
        return this.isNextInSequence;
    }

    /**
     * Gets the value of the followsInSequence property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the followsInSequence property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getFollowsInSequence().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link RelationType }
     * 
     * 
     */
    public List<RelationType> getFollowsInSequence() {
        if (followsInSequence == null) {
            followsInSequence = new ArrayList<RelationType>();
        }
        return this.followsInSequence;
    }

    /**
     * Gets the value of the sameAs property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the sameAs property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getSameAs().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link RelationType }
     * 
     * 
     */
    public List<RelationType> getSameAs() {
        if (sameAs == null) {
            sameAs = new ArrayList<RelationType>();
        }
        return this.sameAs;
    }

    /**
     * Gets the value of the isMemberOf property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the isMemberOf property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getIsMemberOf().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link RelationType }
     * 
     * 
     */
    public List<RelationType> getIsMemberOf() {
        if (isMemberOf == null) {
            isMemberOf = new ArrayList<RelationType>();
        }
        return this.isMemberOf;
    }

    /**
     * Gets the value of the hasMember property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the hasMember property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getHasMember().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link RelationType }
     * 
     * 
     */
    public List<RelationType> getHasMember() {
        if (hasMember == null) {
            hasMember = new ArrayList<RelationType>();
        }
        return this.hasMember;
    }

    /**
     * Gets the value of the coverage property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the coverage property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getCoverage().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link CoverageType }
     * 
     * 
     */
    public List<CoverageType> getCoverage() {
        if (coverage == null) {
            coverage = new ArrayList<CoverageType>();
        }
        return this.coverage;
    }

    /**
     * Gets the value of the rights property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the rights property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getRights().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link RightsType }
     * 
     * 
     */
    public List<RightsType> getRights() {
        if (rights == null) {
            rights = new ArrayList<RightsType>();
        }
        return this.rights;
    }

    /**
     * Gets the value of the version property.
     * 
     * @return
     *     possible object is
     *     {@link BmContentDescriptionType.Version }
     *     
     */
    public BmContentDescriptionType.Version getVersion() {
        return version;
    }

    /**
     * Sets the value of the version property.
     * 
     * @param value
     *     allowed object is
     *     {@link BmContentDescriptionType.Version }
     *     
     */
    public void setVersion(BmContentDescriptionType.Version value) {
        this.version = value;
    }

    /**
     * Gets the value of the rating property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the rating property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getRating().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link RatingType }
     * 
     * 
     */
    public List<RatingType> getRating() {
        if (rating == null) {
            rating = new ArrayList<RatingType>();
        }
        return this.rating;
    }

    /**
     * Gets the value of the audienceRating property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the audienceRating property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getAudienceRating().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link RatingType }
     * 
     * 
     */
    public List<RatingType> getAudienceRating() {
        if (audienceRating == null) {
            audienceRating = new ArrayList<RatingType>();
        }
        return this.audienceRating;
    }

    /**
     * Gets the value of the part property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the part property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getPart().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link PartType }
     * 
     * 
     */
    public List<PartType> getPart() {
        if (part == null) {
            part = new ArrayList<PartType>();
        }
        return this.part;
    }

    /**
     * Gets the value of the lang property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getLang() {
        return lang;
    }

    /**
     * Sets the value of the lang property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setLang(String value) {
        this.lang = value;
    }


    /**
     * <p>Java class for anonymous complex type.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;simpleContent>
     *     &lt;extension base="&lt;http://description.fims.tv>textElementType">
     *       &lt;attGroup ref="{http://description.fims.tv}typeGroup"/>
     *     &lt;/extension>
     *   &lt;/simpleContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class Version
        extends TextElementType
    {

        @XmlAttribute(name = "typeLabel")
        protected String typeLabel;
        @XmlAttribute(name = "typeDefinition")
        protected String typeDefinition;
        @XmlAttribute(name = "typeLink")
        @XmlSchemaType(name = "anyURI")
        protected String typeLink;
        @XmlAttribute(name = "typeSource")
        protected String typeSource;
        @XmlAttribute(name = "typeNamespace")
        protected String typeNamespace;
        @XmlAttribute(name = "typeLanguage")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlSchemaType(name = "language")
        protected String typeLanguage;

        /**
         * Gets the value of the typeLabel property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getTypeLabel() {
            return typeLabel;
        }

        /**
         * Sets the value of the typeLabel property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */
        public void setTypeLabel(String value) {
            this.typeLabel = value;
        }

        /**
         * Gets the value of the typeDefinition property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getTypeDefinition() {
            return typeDefinition;
        }

        /**
         * Sets the value of the typeDefinition property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */
        public void setTypeDefinition(String value) {
            this.typeDefinition = value;
        }

        /**
         * Gets the value of the typeLink property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getTypeLink() {
            return typeLink;
        }

        /**
         * Sets the value of the typeLink property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */
        public void setTypeLink(String value) {
            this.typeLink = value;
        }

        /**
         * Gets the value of the typeSource property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getTypeSource() {
            return typeSource;
        }

        /**
         * Sets the value of the typeSource property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */
        public void setTypeSource(String value) {
            this.typeSource = value;
        }

        /**
         * Gets the value of the typeNamespace property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getTypeNamespace() {
            return typeNamespace;
        }

        /**
         * Sets the value of the typeNamespace property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */
        public void setTypeNamespace(String value) {
            this.typeNamespace = value;
        }

        /**
         * Gets the value of the typeLanguage property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getTypeLanguage() {
            return typeLanguage;
        }

        /**
         * Sets the value of the typeLanguage property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */
        public void setTypeLanguage(String value) {
            this.typeLanguage = value;
        }

    }

}
